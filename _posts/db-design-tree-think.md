title: 数据库 - 树形结构几个思路
date: 2013-07-22 20:17:54
tags: DB Design
categories: DB Design
---


我们经常会对一些级联，关系型的数据弄成一个树形的机构，像城市（省，市，镇，乡），权利，结构等

数据元素之间存在着“一对多”的树形关系的数据结构.

我们需要一个简单高效的方案来获得各个Node。

## 1. 邻接表

表添加parent_id字段，引用同一张表的父Id的机构。

    +----------+--------------+------+-----+---------+-------+
    | Field    | Type         | Null | Key | Default | Extra |
    +----------+--------------+------+-----+---------+-------+
    | id       | int(11)      | NO   | PRI | NULL    |       |
    | name     | varchar(255) | YES  |     | NULL    |       |
    | parentid | int(11)      | YES  |     | 0       |       |
    | level    | int(11)      | YES  |     | 1       |       |
    +----------+--------------+------+-----+---------+-------+

分层存储，逻辑清晰，不过，要用一条简单的sql语句检索多节点的分支还是有困难。只能到达一个固定的深度。

如果数据量不大的情况下，临近表是最通用简单的一种设计方案。

它无法做到查询一个节点后的所有后代，可能我们用一个关联查询，但最多也只能不优雅的取出前面几层
另外一种方案是获得所有行，在应用程序中重新构造出这颗树。

在处理数据之前就进行从数据库到应用程序的大量的数据复制，是非常低效的，你可能仅仅需要一颗子树，而不是从根开始的完整的树；或者可能仅仅需要这些数据的聚合信息。。。

但通过邻接表操作新增/修改一个节点是非常的方便。
删除一个节点稍复杂，需要删除这颗子树。

对于小型数据，我们不需要过度设计，临近表清晰易用，满足大部分需求。

## 2. 路径枚举

路径枚举通过将所有的祖先的信息联合，保存为每个节点的一个属性，解决了邻接表从树中获取一个给定节点的所有祖先的开销很大。

路径枚举是一个由连续的直接层级关系组成的完整路径。如/USR/LOCAL/LIB/ 的UNIX路径是文件系统的一个路径枚举。

    +-------+--------------+------+-----+---------+-------+
    | Field | Type         | Null | Key | Default | Extra |
    +-------+--------------+------+-----+---------+-------+
    | id    | int(11)      | NO   | PRI | NULL    |       |
    | path  | varchar(255) | YES  |     | NULL    |       |
    | name  | varchar(255) | YES  |     | NULL    |       |
    +-------+--------------+------+-----+---------+-------+

    +----+--------+--------+
    | id | path   | name   |
    +----+--------+--------+
    |  1 | 1/     | Frist  |
    |  2 | 1/2/   | Olile  |
    |  3 | 1/2/3/ | Apple  |
    |  4 | 1/4/   | Orange |
    |  5 | 1/4/5/ | Fran   |
    +----+--------+--------+

可以通过比较每个节点的路径来查询一个节点的祖先。比如我要要查询 id5 的祖先。

    SELECT * FROM Table as t WHERE '1/4/5/' LIKE t.path || '%';

这句查询语句会匹配到路径为1/4/% 1/% 的节点。这些节点就是祖先。

同时还可以通过将LIKE 关键字两边的参数互换，来查询一个给定节点的所有后代。

比如查询1/4的所有后代。

    SELECT * FROM Table as t WHERE c.path LIKE '1/4/' || '%';

这句查询语句所找到的后代路径就是 1/4/5/

数据库不能正确保证路径格式总是正确，或者路径中的节点确实存在。依赖逻辑来维护路径的字符串，并且验证字符串的正确性开销很大。

无论将VARCHAR 的长度设定为多大，依旧存在长度限制，因而并不能够支持树结构的无限扩展。

## 3. 嵌套集

该解决方案存储子孙节点的相关信息，而不是节点的直接祖先。

    +-------+---------+------+-----+---------+-------+
    | Field | Type    | Null | Key | Default | Extra |
    +-------+---------+------+-----+---------+-------+
    | id    | int(11) | NO   | PRI | NULL    |       |
    | left  | int(11) | YES  |     | NULL    |       |
    | right | int(11) | YES  |     | NULL    |       |
    +-------+---------+------+-----+---------+-------+

这个就不概述了，网上很多，随便搜的http://www.iteye.com/topic/608748

如果简单快速的查询是整个程序中最重要的部分，嵌套集是最佳的选择，比操作单独的节点要方便快捷的更多，然而，嵌套集的插入和移动节点是比较复杂的，需要重新分配左右值，如果你的应用程序要频繁的插入/删除节点，那么嵌套集可能并不适合。

## 4. 闭包表

闭包表是解决分级存储的一个简单而优雅的解决方案，它记录了树中所有节点间的关系，而不仅仅只有那些直接的父子关系。
我们额外设计一张TreePaths的表，它包含两列，没一列都是一个id

    CATES
    +--------+------------------+------+-----+---------+----------------+
    | Field  | Type             | Null | Key | Default | Extra          |
    +--------+------------------+------+-----+---------+----------------+
    | cateId | int(10) unsigned | NO   | PRI | NULL    | auto_increment |
    | name   | varchar(255)     | NO   |     |         |                |
    | top    | int(11)          | NO   |     | 0       |                |
    +--------+------------------+------+-----+---------+----------------+

    TREEPATHS
    +----------+---------+------+-----+---------+-------+
    | Field    | Type    | Null | Key | Default | Extra |
    +----------+---------+------+-----+---------+-------+
    | parentId | int(11) | NO   | PRI | NULL    |       |
    | sonId    | int(11) | NO   | PRI | NULL    |       |
    | depth    | int(11) | NO   |     | 1       |       |
    +----------+---------+------+-----+---------+-------+

    -- SELECT --
    +--------+----------+-----+
    | cateId | name     | top |
    +--------+----------+-----+
    |     51 | 游戏     |   1 |
    |     52 | 棋牌     |   0 |
    |     53 | 扑克     |   0 |
    |     54 | 扎金花   |   0 |
    |     55 | 其他游戏 |   0 |
    +--------+----------+-----+

    +----------+-------+-------+
    | parentId | sonId | depth |
    +----------+-------+-------+
    |       51 |    51 |     1 |
    |       52 |    52 |     1 |
    |       51 |    52 |     2 |
    |       53 |    53 |     1 |
    |       52 |    53 |     2 |
    |       51 |    53 |     3 |
    |       54 |    54 |     1 |
    |       53 |    54 |     2 |
    |       52 |    54 |     3 |
    |       51 |    54 |     4 |
    |       55 |    55 |     1 |
    |       51 |    55 |     2 |
    +----------+-------+-------+

获取祖先和子孙都非常直接。
搜索祖先是54

    SELECT C.* FROM CATES AS C 
        JOIN TREEPATHS AS T ON C.cateId = T.sonId 
    WHERE T.parentId = 54;

获取所有54的祖先，只需要搜索TREEPATHS中后代是54的行就可以。

    SELECT C.* FROM CATES AS C
        JOIN TREEPATHS AS T ON C.cateId = T.parentId
    WHERE T.sonId = 54;

要插入一个新的叶子节点，应首先要插入一条自己到自己的关系。然后搜索TREEPATHS表后代是评论54的节点，增加该节点和新插入节点的“祖先-后代”关系，包括自身。

删除同理

删除并不会真正的删除CATES表的数据，对于产品目录，或者员工组织架构的图表中，你删除关系，并不是想将他们去掉。
这里不说怎么移动一个树倒另外一个地方的具体办法，首先要断开这颗树和它的祖先的关系，查询这个树的定点，删除它的所有
子节点和她的所有祖先间的关系。

然后建立关系。可以用CROSS JOIN语句来创建一个新节点以及祖先和这颗树中的所有节点间的笛卡尔积来建立所有需要的关系。
level 方便查询子集的1层，或者几层的数据

总结
每种设计都有优劣，如何选择设计依赖于应用程序的哪种操作需要性能上的优化。

    +----------+----+--------+--------+------+------+------------+
    | 设计     | 表 | 查询子 | 查询树 | 插入 | 删除 | 引用完整性 |
    +----------+----+--------+--------+------+------+------------+
    | 邻接表   | 1  | Easy   | Hard   | Easy | Easy | Yes        |
    | 递归查询 | 1  | Easy   | Easy   | Easy | Easy | Yes        |
    | 枚举类型 | 1  | Easy   | Easy   | Easy | Easy | No         |
    | 嵌套集   | 1  | Hard   | Easy   | Hard | Hard | No         |
    | 闭包表   | 2  | Easy   | Easy   | Easy | Easy | Yes        |
    +----------+----+--------+--------+------+------+------------+

* 邻接表是最方便的设计。
* 如果你的数据库是ORACLE或者支持WITH或者CONNECT BY PRIOR 的递归查询，那能使得邻接表查询更为高效
* 枚举路径能够只管的展示路径关系，但是不能保持引用的完整性，设计非常脆弱，也使得数据比较冗余
* 闭包表是最通用的设计，需要额外的一个表来存储，使用空间换时间的方案减少操作过程中的冗余的计算所造成消耗。
* 关于存储的分层数据，还有很多, Jeo Celko <Trees and Hierarchies in SQL for Smarties> SQL Design Patterns
* 一个分层层的数据结构包含了数据项和他们之间的关系，需要合理的设计两者的模型来配合你的工作。


<abbr title="End of file">EOF</abbr>